#!/bin/env python2.7
'''
"mkconf"

An Apache Web Server configuration generation script.
'''

# ------- Python Library Imports -------

# Standard Library
import argparse
import glob
import logging
import os
import re
import shutil
import socket
import subprocess
import sys

# Additional Dependencies
if not '-v' in sys.argv and not '--validate' in sys.argv:
    try:
        import jinja2
    except ImportError as e:
        exit('Unable to import Jinja2 library - ' + str(e) + '.')
     
    try:
        import yaml
    except ImportError as e:
        exit('Unable to import PyYAML library - ' + str(e) + '.')

# --------------------------------------



# ----------- Initialization -----------

HELP_DESCRIPTION = """
An Apache Web Server configuration generation script.
"""

HELP_EPILOG = """

----- Environment Variables -----

The following maps each available environment variable with its corresponding CLI argument:

MKCONF_BLOCK_END_STR      :  --block-end-string
MKCONF_BLOCK_START_STR    :  --block-start-string
MKCONF_COMMENT_END_STR    :  --comment-end-string
MKCONF_COMMENT_START_STR  :  --comment-start-string
MKCONF_EMAIL_LVL          :  --email-level
MKCONF_EMAIL_TO           :  --email-to
MKCONF_EXCLUDE            :  --exclude
MKCONF_LOG_FILE           :  --log-file
MKCONF_LOG_LVL            :  --log-level
MKCONF_LOG_MODE           :  --log-mode
MKCONF_OUTPUT             :  --output
MKCONF_RSYNC_PATH         :  --rsync-executable
MKCONF_VAR_END_STR        :  --variable-end-string
MKCONF_VAR_START_STR      :  --variable-start-string
MKCONF_WORKING_DIR        :  --working-directory

------------ Examples -----------

$ mkconf example/mkconf.yaml example/templates -o example/out
    Generates a new set of Apache Web Server configuration files into the
    "example/out" directory relative to the current working directory.

$ mkconf example/mkconf.yaml example/templates -f /var/log/mkconf.log
    Generates a new set of Apache Web Server configuration files into the
    default "/etc/httpd" directory and enables process logging to the specified
    log file.
"""

# Color Sequences
C_BLUE   = '\033[94m'
C_GREEN  = '\033[92m'
C_ORANGE = '\033[93m'
C_RED    = '\033[91m'
C_END    = '\033[0m'
C_BOLD   = '\033[1m'

# Regular Expressions
grp_directive_regex = re.compile(r'^\s*\<(?P<name>[a-zA-Z]+)\s*(?P<value>.*)\>$')
ifconfig_regex      = re.compile(r'^(?P<int>[\w]+:?[0-9]*)\s+Link[\s\w:]+addr:(?P<ip>[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3})[ \w:\.]+Mask:(?P<mask>[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3})\s+UP')
ip_regex            = re.compile(r'^[0-9]+: (?P<int>[\w:]+): \<[\s\w,]+\>[\s\w/:]+inet (?P<ip>[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3})/(?P<maskbits>[0-9]+)')
valid_fqdn_regex    = re.compile(r'(?=^.{1,253}$)(^(((?!-)[a-zA-Z0-9-]{1,63}(?<!-))|((?!-)[a-zA-Z0-9-]{1,63}(?<!-)\.)+[a-zA-Z]{2,63})$)')

# Possible Paths
service_possible_paths = [
    '/sbin/service',
    '/usr/sbin/service'
]
init_script_possible_paths = [
    '/etc/init.d/httpd',
    '/etc/init.d/apache'
]

# --------------------------------------



# ------------ Email Bodies ------------

PRE_MSG = 'The mkconf script reports that'

CANT_CREATE_BACKUP = """
{pre} it was unable to create a backup of the preexisting files within the output directory.
""".format(pre=PRE_MSG)

CANT_CREATE_BACKUP_DIR = """
{pre} it encountered an exception while trying to create the backup directory.
""".format(pre=PRE_MSG)

CANT_CREATE_OUTPUT_DIR = """
{pre} it encountered an exception while trying to create the specified output directory.
""".format(pre=PRE_MSG)

CANT_CREATE_WORKING_DIR = """
{pre} it encountered an exception while trying to create the specified working directory.
""".format(pre=PRE_MSG)

CANT_DELETE_WORKING_DIR = """
{pre} it encountered an exception while trying to delete the specified working directory.
""".format(pre=PRE_MSG)

CANT_INITIALIZE_ENVIRONMENT = """
{pre} it encountered an exception while trying to initialize the Jinja templating environment.
""".format(pre=PRE_MSG)

CANT_INITIALIZE_EXTENSIONS = """
{pre} it encountered an exception while trying to initialize the Jinja templating extensions.
""".format(pre=PRE_MSG)

CANT_INITIALIZE_LOADER = """
{pre} it encountered an exception while trying to initialize the Jinja templating loader.
""".format(pre=PRE_MSG)

CANT_LOAD_TEMPLATE = """
{pre} it encountered an exception while trying to load one of the specified source templates.
""".format(pre=PRE_MSG)

CANT_PARSE_TEMPLATE_CONF = """
{pre} it encountered an exception while trying to parse the template configuration YAML file.
""".format(pre=PRE_MSG)

CANT_READ_TEMPLATE_CONF = """
{pre} it encountered an exception while trying to read the template configuration YAML file.
""".format(pre=PRE_MSG)

CANT_RENDER_TEMPLATE = """
{pre} it encountered an exception while trying to render one of the specified source templates.
""".format(pre=PRE_MSG)

CANT_RESTART_HTTPD = """
{pre} it encountered an issue while trying to reload or restart the Apache Web Server service.
""".format(pre=PRE_MSG)

CANT_WRITE_OUTPUT = """
{pre} it was unable to write the newly-generated configuration files to the specified output directory.
""".format(pre=PRE_MSG)

COMPLETE = """
{pre} the Apache Web Server configuration process completed successfully.
""".format(pre=PRE_MSG)

INVALID_GROUP_DIRECTIVE = """
{pre} it encountered an invalid group directive specification in one of the generated configuration files during the validation process.
""".format(pre=PRE_MSG)

INVALID_SERVER_NAME = """
{pre} it encountered an invalid ServerName directive specification in one of the generated configuration files during the validation process.
""".format(pre=PRE_MSG)

INVALID_TEMPLATE_CONF = """
{pre} the specified template configuration file has one or more missing or invalid specifications.
""".format(pre=PRE_MSG)

REL_SERVER_ROOT = """
{pre} it encountered an relative-path ServerRoot directive in one of the generated configuration files during the validation process.
""".format(pre=PRE_MSG)

RSYNC_DOESNT_EXIST = """
{pre} the specified rsync executable path does not exist on the local filesystem.
""".format(pre=PRE_MSG)

TEMPLATE_CONF_DOESNT_EXIST = """
{pre} the specified template configuration YAML file does not exist.
""".format(pre=PRE_MSG)

TEMPLATE_CONF_DIR_DOESNT_EXIST = """
{pre} the "conf" subdirectory of specified template source directory does not exist.
""".format(pre=PRE_MSG)

TEMPLATE_FILE_NOT_FOUND = """
{pre} one or more of the template files in the "templates" specification of the template configuration YAML file do not exist.
""".format(pre=PRE_MSG)

TEMPLATE_HTTPD_CONF_DOESNT_EXIST = """
{pre} the "httpd.conf" template within the "conf" subdirectory of the specified template source directory does not exist.
""".format(pre=PRE_MSG)

TEMPLATE_SOURCE_DIR_DOESNT_EXIST = """
{pre} the specified template source directory does not exist.
""".format(pre=PRE_MSG)

TEMPLATE_VHOST_DIR_DOESNT_EXIST = """
{pre} the "vhosts.d" subdirectory of specified template source directory does not exist.
""".format(pre=PRE_MSG)

VALIDATION_WARNINGS = """
{pre} the following warnings were encountered while validating the generated Apache Web Server configuration files:


""".format(pre=PRE_MSG)

VHOST_TEMPLATE_NOT_FOUND = """
{pre} one or more of the vhost templates in the "virtual_hosts" specification of the template configuration YAML file do not exist.
""".format(pre=PRE_MSG)

WORKING_DIR_IS_FILE = """
{pre} the specified working directory is an already existing file.
""".format(pre=PRE_MSG)

# --------------------------------------



# ---------- Private Functions ---------


def _c(instring, color=C_BLUE):
    '''
    Colorizes the specified string.
    '''
    if args.color_output and not color is None:
        return color + instring + C_END
    else:
        return instring

    
def _directive_match(instring, directive):
    '''
    Discerns whether the specified string matches the given Apache Web Server
    directive, returning the value of the directive if it exists and an empty
    string if it does not.
    '''
    match = re.match(r'^\s*' + directive + r'\s+(.+)$', instring)
    if match:
        return match.group(1)
    else:
        return ''

    
def _domain_join(*variables):
    '''
    A Jinja function that acts like os.path.join but with domain strings.
    '''
    return '.'.join([x.strip('.') for x in variables])


def _get_host(ip):
    '''
    A Jinja function that returns the host of a particular IP.
    '''
    try:
        return socket.gethostbyaddr(ip)[0]
    except Exception as e:
        raise Exception("get_host('" + ip + "') - Unable to obtain host for specified IP address - " + str(e) + '.')

    
def _get_ip(host):
    '''
    A Jinja function that returns the IP of a particular host.
    '''
    try:
        return socket.gethostbyname(host)
    except Exception as e:
        raise Exception("get_ip('" + host + "') - Unable to obtain IP address for specified host - " + str(e) + '.')

    
def _is_group_directive(instring):
    '''
    Discerns whether the specified string matches the given Apache Web Server
    group directive, returning the name and value of the directive if it exists and an
    empty string if it does not.
    '''
    match = grp_directive_regex.match(instring)
    if match:
        return {'name': match.group('name'), 'value': match.group('value')}
    else:
        return {}
    

def _parse_arguments():
    '''
    Parses the command-line arguments into a global dictionary called "args".
    '''
    # Do some pre-parsing for some of the environment variables to prevent crashes
    if not os.getenv('MKCONF_EMAIL_LVL', 'never') in ['never','error','warning','completion']:
        exit('Invalid value set for environment variable "MKCONF_EMAIL_LVL".')
    if not os.getenv('MKCONF_LOG_LVL', 'info') in ['info', 'debug']:
        exit('Invalid value set for environment variable "MKCONF_LOG_LVL".')
    if not os.getenv('MKCONF_LOG_MODE', 'append') in ['append', 'overwrite']:
        exit('Invalid value set for environment variable "MKCONF_LOG_MODE".')
    argparser = argparse.ArgumentParser(
        description = HELP_DESCRIPTION,
        epilog = HELP_EPILOG,
        usage = 'mkconf TEMPLATE_CONF TEMPLATE_SOURCE [-o DEST] [...]',
        add_help = False,
        formatter_class = lambda prog: argparse.RawDescriptionHelpFormatter(prog, max_help_position=45, width=100)
    )
    # Pre-parse for --revert and --validate
    if not '--revert' in sys.argv and not '-v' in sys.argv and not '--validate' in sys.argv:
        argparser.add_argument(
            'template_conf',
            help = 'Specifies the path to the template configuration YAML file. If a directory is supplied, then mkconf will look for a YAML file called "mkconf.yaml" or one with a name closest to the hostname of the executing machine.',
        )
        argparser.add_argument(
            'template_source',
            help = 'Specifies the source directory of the Apache Web Server configuration templates.',
        )
    # Note that the "add_argument" statements for "--block-end-string" and
    # "--block-start-string" look like the help string claims that the default
    # has an extra "%", but this is actually required as the argparse module
    # allows for help-message formatting.
    argparser.add_argument(
        '--block-end-string',
        default = os.getenv('MKCONF_BLOCK_END_STR', '%}'),
        dest = 'block_end_string',
        help = 'Specifies the string marking the end of a Jinja template block. Defaults to "%%}".',
        metavar = 'STR'
    )
    argparser.add_argument(
        '--block-start-string',
        default = os.getenv('MKCONF_BLOCK_START_STR', '{%'),
        dest = 'block_start_string',
        help = 'Specifies the string marking the start of a Jinja template block. Defaults to "{%%".',
        metavar = 'STR'
    )
    argparser.add_argument(
        '--comment-end-string',
        default = os.getenv('MKCONF_COMMENT_END_STR', '#}'),
        dest = 'comment_end_string',
        help = 'Specifies the string marking the end of a Jinja template comment. Defaults to "#}".',
        metavar = 'STR'
    )
    argparser.add_argument(
        '--comment-start-string',
        default = os.getenv('MKCONF_COMMENT_START_STR', '{#'),
        dest = 'comment_start_string',
        help = 'Specifies the string marking the start of a Jinja template comment. Defaults to "{#".',
        metavar = 'STR'
    )
    argparser.add_argument(
        '--delete',
        action = 'store_true',
        dest = 'delete',
        help = 'Specifies that the script should delete any files in the output directory that are not part of the generated configuration. Certain files and subdirectories may be preserved with the "--exclude" option.'
    )
    argparser.add_argument(
        '--dont-trim-blocks',
        action = 'store_false',
        dest = 'trim_jinja_blocks',
        help = 'Specifies that the first newline character after a Jinja block should NOT be removed.'
    )
    argparser.add_argument(
        '-d',
        '--dry-run',
        action = 'store_true',
        dest = 'dry_run',
        help = 'Specifies that the script should only execute a dry-run, preventing the generated configuration files from being copied from the working directory to the output directory.'
    )
    argparser.add_argument(
        '-e',
        '--email-level',
        choices = ['never', 'error', 'warning', 'completion'],
        default = os.getenv('MKCONF_EMAIL_LVL', 'never'),
        dest = 'email_level',
        help = 'Specifies the condition at which the script should send an email, being "never", "error", "warning", or "completion". Defaults to "never".',
        metavar = 'LVL'
    )
    argparser.add_argument(
        '-t',
        '--email-to',
        default = os.getenv('MKCONF_EMAIL_TO', ''),
        dest = 'email_to',
        help = 'Specifies the email address to receive sent emails. This option is ignored if "-e" is not specified or set to "never".',
        metavar = 'EMAIL'
    )
    argparser.add_argument(
        '--exclude',
        default = os.getenv('MKCONF_EXCLUDE', '').split(' '),
        dest = 'exclude',
        help = 'Specifies an additional list of files or directories relative to the specified output directory that should be preserved on write (if "--delete" is supplied). The script automatically preserves the "logs", "modules", and "run" subdirectories.',
        metavar = 'PATH',
        nargs = '+'
    )
    argparser.add_argument(
        '-h',
        '--help',
        action = 'help',
        help = 'Displays help and usage information.'
    )
    argparser.add_argument(
        '-i',
        '--ignore-validation-warnings',
        action = 'store_true',
        dest = 'ignore_validation_warnings',
        help = 'Disables printing/logging of warning-level issues during the generated configuration validation process.'
    )
    argparser.add_argument(
        '-f',
        '--log-file',
        default = os.getenv('MKCONF_LOG_FILE', ''),
        dest = 'log_file',
        help = 'Specifies a log file to write to in addition to stdout/stderr.',
        metavar = 'FILE'
    )
    argparser.add_argument(
        '-l',
        '--log-level',
        choices = ['info', 'debug'],
        default = os.getenv('MKCONF_LOG_LVL', 'info'),
        dest = 'log_level',
        help = 'Specifies the log level of the script, being either "info" or "debug". Defaults to "info". This option is ignored if "--log-file" is not specified.',
        metavar = 'LVL'
    )
    argparser.add_argument(
        '-m',
        '--log-mode',
        choices = ['append', 'overwrite'],
        default = os.getenv('MKCONF_LOG_MODE', 'append'),
        dest = 'log_mode',
        help = 'Specifies whether to "append" or "overwrite" the specified log file. Defaults to "append". This option is ignored if "--log-file" is not specified.',
        metavar = 'MODE'
    )
    argparser.add_argument(
        '--no-backup',
        action = 'store_false',
        dest = 'do_backup',
        help = 'Specifies that the script should not perform a backup of the specified output directory prior to writing the generated configuration files.'
    )
    argparser.add_argument(
        '--no-color',
        action = 'store_false',
        dest = 'color_output',
        help = 'Disables color output to stdout/stderr.'
    )
    argparser.add_argument(
        '-o',
        '--output',
        default = os.getenv('MKCONF_OUTPUT', '/etc/httpd'),
        dest = 'output',
        help = 'Specifies the output directory of the generated templates. Defaults to "/etc/httpd/".',
        metavar = 'DIR'
    )
    argparser.add_argument(
        '-r',
        '--reload-httpd',
        action = 'store_true',
        dest = 'reload_httpd',
        help = 'Specifies that the local Apache Web Server service should be reloaded in-place after the generated configuration has been written to the specified output directory. This option is incompatible with "--restart-httpd".'
    )
    argparser.add_argument(
        '--restart-httpd',
        action = 'store_true',
        dest = 'restart_httpd',
        help = 'Specifies that the local Apache Web Server service should be restarted after the generated configuration has been written to the specified output directory. This option is incompatible with "--reload-httpd".'
    )
    argparser.add_argument(
        '--revert',
        const = 'DEFAULT',
        default = '',
        dest = 'revert',
        help = 'Restores the contents of an existing backup directory relative to the specified output directory. If a path is provided alongside this flag, that location will instead be utilized as the restoration source.',
        metavar = 'DIR',
        nargs = '?'
    )
    argparser.add_argument(
        '--rsync-executable',
        default = os.getenv('MKCONF_RSYNC_PATH', '/usr/bin/rsync'),
        dest = 'rsync_executable',
        help = 'Specifies a file path to the rsync executable utilized for transferring directories. Defaults to "/usr/bin/rsync".',
        metavar = 'FILE'
    )
    argparser.add_argument(
        '-v',
        '--validate',
        const = 'DEFAULT',
        default = '',
        dest = 'validate',
        help = 'Performs the validation step for all configuration files in the specified directory, or within the default output directory if none is supplied.',
        metavar = 'DIR',
        nargs = '?'
    )
    argparser.add_argument(
        '--variable-end-string',
        default = os.getenv('MKCONF_VAR_END_STR', '}}'),
        dest = 'variable_end_string',
        help = 'Specifies the string marking the end of a Jinja template variable. Defaults to "}}".',
        metavar = 'STR'
    )
    argparser.add_argument(
        '--variable-start-string',
        default = os.getenv('MKCONF_VAR_START_STR', '{{'),
        dest = 'variable_start_string',
        help = 'Specifies the string marking the start of a Jinja template variable. Defaults to "{{".',
        metavar = 'STR'
    )
    argparser.add_argument(
        '-w',
        '--working-directory',
        default = os.getenv('MKCONF_WORKING_DIR', '/tmp/mkconf'),
        dest = 'working_directory',
        help = 'Specifies the working directory. Defaults to "/tmp/mkconf".',
        metavar = 'DIR'
    )
    global args
    args = argparser.parse_args()


def _raise(message):
    '''
    A mkconf-provided Jinja function that raises an exception with the supplied
    message.
    '''
    raise Exception(message)


def _rsync(src, dst, rsync_args=''):
    '''
    Performs an rsync from the specified source path to the specified
    destination path.
    '''
    if args.dry_run:
        true_rsync_args = rsync_args + ' --dry-run'
    else:
        true_rsync_args = rsync_args
    cmd = '{rsync_exec} {args} {src} {dst}'.format(
        rsync_exec = args.rsync_executable,
        args = true_rsync_args,
        src = src,
        dst = dst
    )
    return _run_process(cmd)

    
def _run_process(cmd, splitlines=True):
    '''
    Runs the specified command as a subprocess, returning the output of the
    command (optionally not split by lines) and its exit code.
    '''
    process = subprocess.Popen(
        cmd,
        stdout = subprocess.PIPE,
        stderr = subprocess.STDOUT,
        shell = True
    )
    output = process.communicate()[0]
    exit_code = process.returncode
    if splitlines:
        return (output.splitlines(), exit_code)
    else:
        return (output, exit_code)


def _send_email(subject, body, level='error'):
    '''
    Sends an email to the configured recipients with the specified body, subject,
    and alert level. Whether the email actually gets sent is dependent on the
    alert level specified by "args.email_level".
    '''
    if not level in ['error', 'warning', 'info']:
        raise Exception('Invalid email level: "' + str(level) + '"')
    if args.email_level == 'never' or (args.email_level == 'error' and level in ['warning', 'info']) or (args.email_level == 'warning' and level == 'info'):
        return
    else:
        if level == 'error':
            full_subject = 'ERROR: ' + subject
            full_body = body + '\n\nSee "' + args.log_file + '" on the machine for more details.'
        elif level == 'warning':
            full_subject = 'WARNING: ' + subject
            full_body = body + '\n\nSee "' + args.log_file + '" on the machine for more details.'
        else:
            full_subject = subject
            full_body = body
        with open('/tmp/mkconf.email', 'w') as f:
            f.write('To: ' + args.email_to + '\n')
            f.write('Subject: ' + full_subject + '\n\n')
            f.write(full_body)
        with open(os.devnull, 'w') as DEVNULL:
            email_exit_code = subprocess.call('cat /tmp/mkconf.email | /usr/sbin/sendmail -t', shell=True, stdout=DEVNULL, stderr=subprocess.STDOUT)
        if email_exit_code != 0:
            raise Exception('sendmail subprocess call returned non-zero exit code')
        else:
            return


def _setup_logging():
    '''
    Sets-up logging.
    '''
    if args.log_file:
        try:
            if args.log_mode == 'append':
                logging_fmode = 'a'
            else:
                logging_fmode = 'w'
            if args.log_level == 'info':
                logging_level = logging.INFO
            else:
                logging_level = logging.DEBUG
            logging.basicConfig(
                filename = args.log_file,
                filemode = logging_fmode,
                level    = logging_level,
                format   = '[%(levelname)s] [%(asctime)s] [%(process)d] [%(module)s.%(funcName)s] %(message)s',
                datefmt  = '%m/%d/%Y %I:%M:%S %p'
            )
            logging.addLevelName(logging.CRITICAL, 'CRI')
            logging.addLevelName(logging.ERROR, 'ERR')
            logging.addLevelName(logging.WARNING, 'WAR')
            logging.addLevelName(logging.INFO, 'INF')
            logging.addLevelName(logging.DEBUG, 'DEB')
        except Exception as e:
            exit('Unable to initialize logging system - ' + str(e) + '.')
    else:
        logger = logging.getLogger()
        logger.disabled = True

        
def _step(instring, color=C_BLUE):
    '''
    Formats the specified string as a "step".
    '''
    return _c('::', color) + ' ' + _c(instring, C_BOLD)


def _substep(instring, color=C_BLUE):
    '''
    Formats the specified string as a "sub-step".
    '''
    return '  ' + _c('-->', color) + ' ' + instring


def _subsubstep(instring, color=None):
    '''
    Formats the specified string as a "sub-sub-step".
    '''
    return '      ' + _c(instring, color)

# --------------------------------------



# ---------- Public Functions ----------

def get_hostname():
    '''
    Obtains the hostname of the machine.
    '''
    logging.debug('Getting hostname and FQDN...')
    try:
        global hostname
        hostname = socket.gethostname().split('.', 1)[0]
        global fqdn
        fqdn = socket.getfqdn()
    except Exception as e:
        logging.critical('Unable to discern hostname - ' + str(e) + '.')
        try:
            _send_email(
                subject = '? - Unable to discern hostname',
                body = UNKNOWN_HOSTNAME,
                level = 'error'
            )
        except Exception as mail_e:
            logging.warning('Unable to send email - ' + str(mail_e) + '.')
        exit(1)
    logging.debug('Hostname: ' + hostname)
    logging.debug('FQDN: ' + fqdn)


def get_network_interfaces():
    '''
    Obtains the collection of network interfaces.
    '''
    logging.debug('Getting network interfaces...')
    global network_interfaces
    network_interfaces = {}
    ifconfig_path = next((p for p in ['/sbin/ifconfig', '/usr/sbin/ifconfig', '/usr/share/sbin/ifconfig', '/usr/local/sbin/ifconfig'] if os.path.isfile(p)), '')
    if ifconfig_path:
        logging.debug('Using "ifconfig" to get network interfaces...')
        try:
            (if_out, if_ec) = _run_process(ifconfig_path, splitlines=False)
        except Exception as e:
            print('   ' + _c('Error: Unable to obtain network interfaces with "ifconfig" - ' + str(e) + '. Script will continue with an empty value for "network_interfaces".', C_RED))
            logging.error('Unable to obtain network interfaces with "ifconfig" - ' + str(e) + '. Script will continue with an empty value for "network_interfaces".')
            return
        logging.debug('IFCONFIG EXIT CODE: ' + str(if_ec))
        if if_ec != 0:
            if if_out:
                for l in if_out.splitlines():
                    logging.error('IFCONFIG OUTPUT: ' + l)
            print('   ' + _c('Error: Unable to obtain network interfaces with "ifconfig" - subprocess returned non-zero exit code. Script will continue with an empty value for "network_interfaces".', C_RED))
            logging.error('Unable to obtain network interfaces with "ifconfig" - subprocess returned non-zero exit code. Script will continue with an empty value for "network_interfaces".')
            return
        else:
            if if_out:
                for l in if_out.splitlines():
                    logging.debug('IFCONFIG OUTPUT: ' + l)
            else:
                print('   ' + _c('Error: Unable to obtain network interfaces with "ifconfig" - subprocess returned no output. Script will continue with an empty value for "network_interfaces".', C_RED))
                logging.error('Unable to obtain network interfaces with "ifconfig" - subprocess returned no output. Script will continue with an empty value for "network_interfaces".')
                return
            found_match = False
            for match in ifconfig_regex.finditer(if_out):
                if match:
                    found_match = True
                    network_interfaces[match.group('int')] = {
                        'ip_address': match.group('ip'),
                        'netmask': match.group('mask')
                    }
            if not found_match:
                print('   ' + _c('Error: Unable to obtain network interfaces with "ifconfig" - unknown subprocess output. Script will continue with an empty value for "network_interfaces".', C_RED))
                logging.error('Unable to obtain network interfaces with "ifconfig" - unknown subprocess output. Script will continue with an empty value for "network_interfaces".')
                return
    else:
        ip_path = next((p for p in ['/usr/bin/ip', '/sbin/ip', '/usr/sbin/ip', '/usr/share/sbin/ip', '/usr/local/sbin/ip'] if os.path.isfile(p)), '')
        if not ip_path:
            print('   ' + _c('Warning: Unable to obtain network interfaces - "ifconfig" or "ip" is required to obtain the network interfaces.', C_RED))
            logging.warning('Unable to obtain network interfaces - "ifconfig" or "ip" is required to obtain the network interfaces.')
            return
        logging.debug('Using "ip" to get network interfaces...')
        try:
            (ip_out, ip_ec) = _run_process(ip_path + ' addr', splitlines=False)
        except Exception as e:
            print('   ' + _c('Error: Unable to obtain network interfaces with "ip" - ' + str(e) + '. Script will continue with an empty value for "network_interfaces".', C_RED))
            logging.error('Unable to obtain network interfaces with "ip" - ' + str(e) + '. Script will continue with an empty value for "network_interfaces".')
            return
        logging.debug('IP EXIT CODE: ' + str(ip_ec))
        if ip_ec != 0:
            if ip_out:
                for l in ip_out.splitlines():
                    logging.error('IP OUTPUT: ' + l)
            print('   ' + _c('Error: Unable to obtain network interfaces with "ip" - subprocess returned non-zero exit code. Script will continue with an empty value for "network_interfaces".', C_RED))
            logging.error('Unable to obtain network interfaces with "ip" - subprocess returned non-zero exit code. Script will continue with an empty value for "network_interfaces".')
            return
        else:
            if ip_out:
                for l in ip_out.splitlines():
                    logging.debug('IP OUTPUT: ' + l)
            else:
                print('   ' + _c('Error: Unable to obtain network interfaces with "ip" - subprocess returned no output. Script will continue with an empty value for "network_interfaces".', C_RED))
                logging.error('Unable to obtain network interfaces with "ip" - subprocess returned no output. Script will continue with an empty value for "network_interfaces".')
                return
            found_match = False
            for match in ip_regex.finditer(ip_out):
                if match:
                    found_match = True
                    network_interfaces[match.group('int')] = {
                        'ip_address': match.group('ip'),
                        'maskbits': match.group('maskbits')
                    }
            if not found_match:
                print('   ' + _c('Error: Unable to obtain network interfaces with "ip" - unknown subprocess output. Script will continue with an empty value for "network_interfaces".', C_RED))
                logging.error('Unable to obtain network interfaces with "ip" - unknown subprocess output. Script will continue with an empty value for "network_interfaces".')
                return


def handle_reload_restart():
    '''
    Handles reloading/restarting the Apache Web Server service.
    '''
    if args.reload_httpd:
        print(_substep('Reloading Apache Web Server service...'))
        logging.info('Reloading Apache Web Server service...')
        script_subcommmand = 'reload'
    else:
        print(_substep('Restarting Apache Web Server service...'))
        logging.info('Restarting Apache Web Server service...')
        script_subcommand = 'restart'
    logging.debug('Selecting service executable...')
    service_executable = next((p for p in service_possible_paths if os.path.isfile(p)), '')
    if not service_executable:
        printe(_subsubstep('Unable to reload or restart service - unable to select suitable service executable.', C_RED))
        logging.critical('Unable to reload or restart service - unable to select suitable service executable.')
        send_email(
            'Unable to reload/restart Apache Web Server service',
            CANT_RESTART_HTTPD,
            'error'
        )
        exit(8)
    logging.debug('SELECTED SERVICE EXECUTABLE: ' + service_executable)
    logging.debug('Selecting init script...')
    init_script = next((os.path.basename(p) for p in init_script_possible_paths if os.path.isfile(p)), '')
    if not init_script:
        printe(_subsubstep('Unable to reload or restart service - unable to select suitable init script.', C_RED))
        logging.critical('Unable to reload or restart service - unable to select suitable init script.')
        send_email(
            'Unable to reload/restart Apache Web Server service',
            CANT_RESTART_HTTPD,
            'error'
        )
        exit(8)
    logging.debug('SELECTED INIT SCRIPT: ' + init_script)
    command = service_executable + ' ' + init_script + ' '
    if args.reload_httpd:
        command += 'reload'
    else:
        command += 'restart'
    if not args.dry_run:
        try:
            (httpd_out, httpd_ec) = _run_process(command)
        except Exception as e:
            printe(_subsubstep('Unable to reload or restart service - ' + str(e) + '.', C_RED))
            logging.critical('Unable to reload or restart service - ' + str(e) + '.')
            send_email(
                'Unable to reload/restart Apache Web Server service',
                CANT_RESTART_HTTPD,
                'error'
            )
            exit(8)
        logging.debug('SERVICE EXIT CODE: ' + str(httpd_ec))
        if httpd_ec != 0:
            if httpd_out:
                for l in httpd_out:
                    logging.critical('SERVICE OUTPUT: ' + l)
            printe(_subsubstep('Unable to reload or restart service - subprocess returned non-zero exit code.', C_RED))
            logging.critical('Unable to reload or restart service - subprocess returned non-zero exit code.')
            send_email(
                'Unable to reload/restart Apache Web Server service',
                CANT_RESTART_HTTPD,
                'error'
            )
            exit(8)
        if httpd_out:
                for l in httpd_out:
                    logging.debug('SERVICE OUTPUT: ' + l)
    else:
        logging.info('Apache Web Server reload/restart skipped due to dry-run being enabled.')


def handle_revert():
    '''
    Handles --revert.
    '''
    print(_step('Reverting changes...'))
    logging.info('Reverting changes...')
    if args.revert == 'DEFAULT':
        print(_substep('Restoring configuration from dedicated backup...'))
        logging.debug('Restoring configuration from dedicated backup...')
        backup_dir = args.output + '.backup'
    else:
        print(_substep('Restoring configuration from specified directory...'))
        logging.debug('Restoring configuration from specified directory...')
        backup_dir = args.revert
    if not os.path.isdir(backup_dir):
        if args.revert == 'DEFAULT':
            printe(_subsubstep('Unable to restore configuration - dedicated backup directory does not exist.', C_RED))
            logging.critical('Unable to restore configuration - dedicated backup directory does not exist.')
        else:
            printe(_subsubstep('Unable to restore configuration - specified source directory does not exist.', C_RED))
            logging.critical('Unable to restore configuration - specified source directory does not exist.')
        exit(9)
    if not os.path.isdir(args.output):
        try:
            os.makedirs(args.output)
        except Exception as e:
            printe(_subsubstep('Unable to restore configuration - unable to create output directory - ' + str(e) + '.', C_RED))
            logging.critical('Unable to restore configuration - unable to create output directory - ' + str(e) + '.')
            exit(9)
    try:
        (revert_out, revert_ec) = _rsync(
            src = backup_dir.rstrip('/') + '/',
            dst = args.output.rstrip('/') + '/',
            rsync_args = '-a --delete --progress'
        )
    except Exception as e:
        printe(_subsubstep('Unable to restore configuration - ' + str(e) + '.', C_RED))
        logging.critical('Unable to restore configuration - ' + str(e) + '.')
        exit(9)
    logging.debug('REVERT EXIT CODE: ' + str(revert_ec))
    if revert_ec != 0:
        if revert_out:
            for l in revert_out:
                logging.critical('REVERT OUTPUT: ' + l)
        printe(_subsubstep('Unable to restore configuration - subprocess returned non-zero exit code.', C_RED))
        logging.critical('Unable to restore configuration - subprocess returned non-zero exit code.')
        exit(9)
    else:
        if revert_out:
            for l in revert_out:
                logging.debug('REVERT OUTPUT: ' + l)


def handle_validate():
    '''
    Handles -v/--validate.

    We essentially "trick" validate_configs() by computing the paths as if they
    were in the working directory.
    '''
    if args.validate == 'DEFAULT':
        source_dir = args.output
    else:
        source_dir = args.validate
    logging.debug('VALIDATION SOURCE DIRECTORY: ' + source_dir)
    if not os.path.isdir(source_dir):
        printe(_c('Unable to validate configuration - "' + source_dir + '" does not exist.', C_RED))
        logging.critical('Unable to validate configuration - "' + source_dir + '" does not exist.')
        exit(6)
    global working_paths
    try:
        working_paths = [os.path.join(parent, f) for parent, dirs, files in os.walk(source_dir) for f in files]
    except Exception as e:
        printe(_c('Unable to validate configuration - unable to enumerate source directory - ' + str(e) + '.', C_RED))
        logging.critical('Unable to validate configuration - unable to enumerate source directory - ' + str(e) + '.')
        exit(6)
    if not working_paths:
        printe(_c('Unable to validate configuration - default or specified directory does not contain any files.', C_RED))
        logging.critical('Unable to validate configuration - default or specified directory does not contain any files.')
        exit(6)
    logging.debug('VALIDATION WORKING PATHS: ' + str(working_paths))
    args.working_directory = source_dir
    args.output = source_dir
    validate_configs()


def main():
    '''
    The entrypoint of the script.
    '''
    # Parse command-line arguments
    _parse_arguments()

    # Verify some command-line arguments
    if args.email_level != 'never' and not args.email_to:
        printe(_c('Invalid option combination: "--email-to" not specified.', C_RED))
        exit(1)
    if args.reload_httpd and args.restart_httpd:
        printe(_c('Invalid option combination: "-r"/"--reload-httpd" is not compatible with "--restart-httpd".', C_RED))
        exit(1)
    if args.revert and args.validate:
        printe(_c('Invalid option combination: "--revert" is not compatible with "-v"/"--validate".', C_RED))
        exit(1)
    if args.validate and (args.reload_httpd or args.restart_httpd):
        printe(_c('Invalid option combination: "-v"/"--validate" is not compatible with "-r"/"--reload-httpd" or "--restart-httpd".', C_RED))
        exit(1)

    # Setup logging
    _setup_logging()
    if args.revert:
        logging.info('Started revert process.')
    elif args.validate:
        logging.info('Started validation process.')
    else:
        logging.info('Started configuration process.')

    # Get the hostname of the machine
    get_hostname()

    # Get the dictionary of network interfaces for the machine
    #get_network_interfaces()
    global network_interfaces
    network_interfaces = {}
    logging.debug('Skipped network interface parsing.')

    # Log our CLI arguments when in DEBUG mode
    logging.debug('----- CLI Arguments -----')
    dargs = vars(args)
    for a in dargs:
        logging.debug(a + ' : ' + str(dargs[a]))
    logging.debug('-------------------------')

    # Handle --revert or --validate if they are specified
    if args.revert:
        handle_revert()
    elif args.validate:
        handle_validate()
    else:
        # Set-up and validate the environment
        validate_environment()
        
        # Parse template configuration file
        parse_yaml_config()
        
        # Set-up the jinja environment
        setup_jinja()
        
        # Translate templates (saving into the working directory)
        translate_templates()
        
        # Validate the generated configuration files
        validate_configs()
        
        # Write to the output directory
        write_output()

    # Reload/restart httpd if necessary
    if args.reload_httpd or args.restart_httpd:
        handle_reload_restart()

    if args.revert:
        logging.info('Revert process complete.')
    elif args.validate:
        logging.info('Validation process complete.')
    else:
        logging.info('Configuration process complete.')
        send_email(
            'Configuration process complete',
            COMPLETE,
            'info'
        )
    exit(0)


def parse_yaml_config():
    '''
    Parses the template configuration YAML file into a global dictionary object.
    '''
    print(_step('Loading template configuration file...'))
    logging.info('Loading template configuration file...')
    print(_substep('Reading template configuration file...'))
    logging.debug('Reading template configuration file...')
    try:
        with open(args.template_conf, 'r') as yamlf:
            template_conf_raw = yamlf.read()
    except Exception as e:
        printe(_subsubstep('Unable to read template configuration file - ' + str(e) + '.', C_RED))
        logging.critical('Unable to read template configuration file - ' + str(e) + '.')
        send_email(
            'Unable to read template configuration file',
            CANT_READ_TEMPLATE_CONF,
            'error'
        )
        exit(3)
    print(_substep('Parsing template configuration file...'))
    logging.debug('Parsing template configuration file...')
    try:
        global template_conf
        template_conf = yaml.load(template_conf_raw)
    except Exception as e:
        printe(_subsubstep('Unable to parse template configuration file - ' + str(e) + '.', C_RED))
        logging.critical('Unable to parse template configuration file - ' + str(e) + '.')
        send_email(
            'Unable to parse template configuration file',
            CANT_PARSE_TEMPLATE_CONF,
            'error'
        )
        exit(3)
    logging.debug('----- Template Configuration -----')
    for x in template_conf:
        logging.debug(x + ' : ' + str(template_conf[x]))
    logging.debug('----------------------------------')
    print(_substep('Validating template configuration...'))
    logging.debug('Validating template configuration...')
    if not 'templates' in template_conf:
        printe(_subsubstep('Invalid template configuration - "templates" specification not found.', C_RED))
        logging.critical('Invalid template configuration - "templates" specification not found.')
        send_email(
            'Unable to validate template configuration file',
            INVALID_TEMPLATE_CONF,
            'error'
        )
        exit(3)
    if not isinstance(template_conf['templates'], list):
        printe(_subsubstep('Invalid template configuration - "templates" specification is not a list of dictionaries.', C_RED))
        logging.critical('Invalid template configuration - "templates" specification is not a list of dictionaries.')
        send_email(
            'Unable to validate template configuration file',
            INVALID_TEMPLATE_CONF,
            'error'
        )
        exit(3)
    # Pull out the templates into a dictionary of output-input mappings.
    logging.debug('Extracting template file paths...')
    templates = {}
    # templates[OUTPUT (RELATIVE)] = INPUT (RELATIVE)
    for spec in template_conf['templates']:
        if not 'file' in spec:
            printe(_subsubstep('Invalid template configuration - missing "file" key in source templates specification.', C_RED))
            logging.critical('Invalid template configuration - missing "file" key in source templates specification.')
            send_email(
                'Unable to validate template configuration file',
                INVALID_TEMPLATE_CONF,
                'error'
            )
            exit(3)
        file_spec = os.path.join(args.template_source, spec['file'])
        if '*' in spec['file']:
            if 'template' in spec:
                printe(_subsubstep('Invalid template configuration - found "template" key in source templates specification alongside wildcard "file" key.', C_RED))
                logging.critical('Invalid template configuration - found "template" key in source templates specification alongside wildcard "file" key.')
                send_email(
                    'Unable to validate template configuration file',
                    INVALID_TEMPLATE_CONF,
                    'error'
                )
                exit(3)
            g = glob.glob(file_spec)
            if not g:
                printe(_subsubstep('Warning: No files found matching glob "' + file_spec + '".', C_ORANGE))
                logging.warning('No files found matching glob "' + file_spec + '".')
            else:
                for x in g:
                    templates[os.path.relpath(x, args.template_source)] = os.path.relpath(x, args.template_source)
        else:
            if 'template' in spec:
                templates[spec['file']] = spec['template']
            else:
                templates[spec['file']] = spec['file']
    logging.debug('TEMPLATE FILE MAPPINGS: ' + str(templates))
    for f in templates:
        if not os.path.isfile(os.path.join(args.template_source, templates[f])):
            printe(_subsubstep('Invalid template configuration - specified source template "' + templates[f] + '" does not exist.', C_RED))
            logging.critical('Invalid template configuration - specified source template "' + templates[f] + '" does not exist.')
            send_email(
                'Unable to validate template configuration file',
                TEMPLATE_FILE_NOT_FOUND,
                'error'
            )
            exit(3)
    if not 'virtual_hosts' in template_conf:
        printe(_subsubstep('Invalid template configuration - "virtual_hosts" specification not found.', C_RED))
        logging.critical('Invalid template configuration - "virtual_hosts" specification not found.')
        send_email(
            'Unable to validate template configuration file',
            INVALID_TEMPLATE_CONF,
            'error'
        )
        exit(3)
    if not isinstance(template_conf['virtual_hosts'], list):
        printe(_subsubstep('Invalid template configuration - "virtual_hosts" specification is not a list of virtual host specifications.', C_RED))
        logging.critical('Invalid template configuration - "virtual_hosts" specification is not a list of virtual host specifications.')
        send_email(
            'Unable to validate template configuration file',
            INVALID_TEMPLATE_CONF,
            'error'
        )
        exit(3)
    vhost_templates = {}
    # vhost_templates[OUTPUT (RELATIVE)] = INPUT (RELATIVE)
    for vhost in template_conf['virtual_hosts']:
        if not 'file' in vhost:
            printe(_subsubstep('Invalid template configuration - One or more "virtual_hosts" specifications does not contain the required "file" key.', C_RED))
            logging.critical('Invalid template configuration - One or more "virtual_hosts" specifications does not contain the required "file" key.')
            send_email(
                'Unable to validate template configuration file',
                INVALID_TEMPLATE_CONF,
                'error'
            )
            exit(3)
        if 'template' in vhost:
            vhost_templates[os.path.join('vhosts.d', vhost['file'])] = os.path.join('vhosts.d', vhost['template'])
        else:
            vhost_templates[os.path.join('vhosts.d', vhost['file'])] = os.path.join('vhosts.d', vhost['file'])
    logging.debug('VHOST TEMPLATE MAPPINGS: ' + str(vhost_templates))
    for f in vhost_templates:
        if not os.path.isfile(os.path.join(args.template_source, vhost_templates[f])):
            printe(_subsubstep('Invalid template configuration - specified vhost template "' + vhost_templates[f] + '" does not exist.', C_RED))
            logging.critical('Invalid template configuration - specified vhost template "' + vhost_templates[f] + '" does not exist.')
            send_email(
                'Unable to validate template configuration file',
                VHOST_TEMPLATE_NOT_FOUND,
                'error'
            )
            exit(3)
    logging.debug('Finalizing template paths...')
    global template_paths
    template_paths = templates.copy()
    template_paths.update(vhost_templates)


def print_jinja(message):
    '''
    A mkconf-provided Jinja function that prints and logs the specified message.
    '''
    print(_subsubstep(message, C_BLUE))
    logging.info(message)
    return ''

    
def printe(instring):
    '''
    Prints the specified string to stderr.
    '''
    sys.stderr.write(instring + '\n')


if not '-v' in sys.argv and not '--validate' in sys.argv:
    @jinja2.contextfunction
    def require(context, *variables):
        '''
        A Jinja filter which specifies that the specified variables are required.
     
        See:
        http://jinja.pocoo.org/docs/2.10/api/#the-context
        http://jinja.pocoo.org/docs/2.10/api/#jinja2.contextfilter
        '''
        for variable in variables:
            if '.' in variable:
                splitvar = variable.split('.', 1)
                if not splitvar[0] in context:
                    raise Exception('Required variable "' + splitvar[0] + '" not found in within the context of "' + context.name + '".')
                if not splitvar[1] in context[splitvar[0]]:
                    raise Exception('Required variable "' + variable + '" not found in within the context of "' + context.name + '".')
            else:
                if not variable in context:
                    raise Exception('Required variable "' + variable + '" not found in within the context of "' + context.name + '".')
        return ''
    

def send_email(subject, body, level='error'):
    '''
    Sends an email to the configured recipients with the specified body, subject,
    and alert level. Whether the email actually gets sent is dependent on the
    alert level specified by "args.email_level".
    '''
    try:
        _send_email(hostname + ' - ' + subject, body, level)
    except Exception as mail_e:
        logging.warning('Unable to send email - ' + str(mail_e) + '.')


def setup_jinja():
    '''
    Sets-up the Jinja environment for for template parsing.
    '''
    print(_step('Setting-up templating environment...'))
    logging.info('Setting-up templating environment...')
    print(_substep('Initializing loader...'))
    logging.debug('Initializing loader...')
    try:
        fsloader = jinja2.FileSystemLoader(args.template_source)
    except Exception as e:
        printe(_subsubstep('Unable to initialize templating loader - ' + str(e) + '.', C_RED))
        logging.critical('Unable to initialize templating loader - ' + str(e) + '.')
        send_email(
            'Unable to initialize templating loader',
            CANT_INITIALIZE_LOADER,
            'error'
        )
        exit(4)
    print(_substep('Initializing environment...'))
    logging.debug('Initializing environment...')
    try:
        global jinja_env
        jinja_env = jinja2.Environment(
            block_end_string      = args.block_end_string,
            block_start_string    = args.block_start_string,
            comment_end_string    = args.comment_end_string,
            comment_start_string  = args.comment_start_string,
            loader                = fsloader,
            trim_blocks           = args.trim_jinja_blocks,
            variable_end_string   = args.variable_end_string,
            variable_start_string = args.variable_start_string
        )
    except Exception as e:
        printe(_subsubstep('Unable to initialize templating environment - ' + str(e) + '.', C_RED))
        logging.critical('Unable to initialize templating environment - ' + str(e) + '.')
        send_email(
            'Unable to initialize templating environment',
            CANT_INITIALIZE_ENVIRONMENT,
            'error'
        )
        exit(4)
    print(_substep('Initializing extensions...'))
    logging.debug('Initializing extensions...')
    try:
        # Provided variables
        jinja_env.globals['fqdn']               = fqdn
        jinja_env.globals['hostname']           = hostname
        jinja_env.globals['network_interfaces'] = network_interfaces

        # Custom functions
        jinja_env.globals['get_host']    = _get_host
        jinja_env.globals['get_ip']      = _get_ip
        jinja_env.globals['domain_join'] = _domain_join
        jinja_env.globals['path_join']   = os.path.join
        jinja_env.globals['print']       = print_jinja
        jinja_env.globals['raise']       = _raise
        jinja_env.globals['require']     = require
    except Exception as e:
        printe(_subsubstep('Unable to initialize templating extensions - ' + str(e) + '.', C_RED))
        logging.critical('Unable to initialize templating extensions - ' + str(e) + '.')
        send_email(
            'Unable to initialize templating extensions',
            CANT_INITIALIZE_EXTENSIONS,
            'error'
        )
        exit(4)


def translate_templates():
    '''
    Translates the source templates into their final forms within the working
    directory.
    '''
    print(_step('Translating templates...'))
    logging.info('Translating templates...')
    global working_paths
    working_paths = []
    for output_path in template_paths:
        rel_path = template_paths[output_path]
        filename = os.path.basename(template_paths[output_path])
        print(_substep(output_path))
        logging.info('Translating "' + os.path.join(args.template_source, rel_path) + '" into "' + os.path.join(args.working_directory, output_path) + '"...')
        logging.debug('Loading template...')
        try:
            template = jinja_env.get_template(rel_path)
        except Exception as e:
            printe(_subsubstep('Unable to load template - ' + str(e), C_RED))
            logging.critical('Unable to load template - ' + str(e))
            send_email(
                'Unable to load template',
                CANT_LOAD_TEMPLATE,
                'error'
            )
            exit(5)
        try:
            if not rel_path.startswith('vhosts.d/'):
                logging.debug('Rendering regular template...')
                regular_conf = template_conf.copy()
                regular_conf['file'] = filename
                rendered_template = template.render(**regular_conf)
            # If the template is a vhost template, then we set vhost to the
            # relevant entry in virtual_hosts
            else:
                logging.debug('Rendering virtual host template...')
                vhost = next(v for v in template_conf['virtual_hosts'] if ('template' in v and v['template'] == filename) or v['file'] == filename)
                vhost_conf = template_conf.copy()
                vhost_conf['vhost'] = vhost
                vhost_conf['file'] = filename
                rendered_template = template.render(**vhost_conf)
        except jinja2.TemplateSyntaxError as e:
            printe(_subsubstep('Unable to render template - template syntax error on line ' + str(e.lineno) + ' - ' + str(e), C_RED))
            logging.critical('Unable to render template - template syntax error on line ' + str(e.lineno) + ' - ' + str(e))
            send_email(
                'Unable to render template',
                CANT_RENDER_TEMPLATE,
                'error'
            )
            exit(5)
        except Exception as e:
            printe(_subsubstep('Unable to render template - ' + str(e), C_RED))
            logging.critical('Unable to render template - ' + str(e))
            send_email(
                'Unable to render template',
                CANT_RENDER_TEMPLATE,
                'error'
            )
            exit(5)
        logging.debug('Writing rendered configuration file to working directory...')
        working_path = os.path.join(args.working_directory, output_path)
        working_paths.append(working_path)
        if not os.path.isdir(os.path.dirname(working_path)):
            try:
                os.makedirs(os.path.dirname(working_path))
            except Exception as e:
                printe(_subsubstep('Unable to write rendered configuration file to working directory - Unable to create parent directory - ' + str(e), C_RED))
                logging.critical('Unable to write rendered configuration file to working directory - Unable to create parent directory - ' + str(e))
                send_email(
                    'Unable to write template',
                    CANT_WRITE_TEMPLATE,
                    'error'
                )
                exit(5)
        try:
            with open(working_path, 'w') as f:
                f.write(rendered_template)
        except Exception as e:
            printe(_subsubstep('Unable to write rendered configuration file to working directory - ' + str(e), C_RED))
            logging.critical('Unable to write rendered configuration file to working directory - ' + str(e))
            send_email(
                'Unable to write template',
                CANT_WRITE_TEMPLATE,
                'error'
            )
            exit(5)


def validate_configs():
    '''
    Validates the newly generated configuration files within the working directory.
    '''
    print(_step('Validating configuration files...'))
    logging.info('Validating configuration files...')
    global email_warnings
    email_warnings = ''
    def validation_issue(template, issue_string, line_number=0, critical=False):
        '''
        Submethod used to clean-up some of the code redundancy below.
        '''
        global email_warnings
        if critical:
            printe(_subsubstep('[' + str(line_number) + '] Error: ' + issue_string, C_RED))
            logging.critical('(Line ' + str(line_number) + ') ' + issue_string)
        elif not args.ignore_validation_warnings:
            printe(_subsubstep('[' + str(line_number) + '] Warning: ' + issue_string, C_ORANGE))
            logging.warning('(Line ' + str(line_number) + ') ' + issue_string)
            email_warnings += '[' + template + ' : ' + str(line_number) + ']  ' + issue_string + '\n'
    for p in working_paths:
        rel_path = os.path.relpath(p, args.working_directory)
        print(_substep(rel_path))
        logging.info('Validating "' + rel_path + '"...')
        logging.debug('Reading generated configuration file...')
        try:
            with open(p, 'r') as f:
                content = f.read()
        except Exception as e:
            validation_issue('Unable to read generated configuration file - ' + str(e), critical=True)
            send_email(
                'Unable to read generated configuration file for validation',
                CANT_READ_GEN_CONFIG,
                'error'
            )
            exit(6)
        if rel_path == 'conf/httpd.conf':
            logging.debug('Validating "httpd.conf"-specific configuration requirements...')
        # ---------- Single-line Checks ----------
        lines = content.splitlines()
        for (index, l) in enumerate(lines):
            # Skip comments and blank lines
            if l.startswith('#') or l.isspace():
                continue
            # ----- Group Directives -----
            GRP = _is_group_directive(l)
            if GRP:
                logging.debug('GROUP DIRECTIVE: ' + l.strip())
                # Make sure that <foo> is followed by a </foo>
                num_found = 0
                num_required = 0 # Note that we start on the same line to avoid overflows
                for after in lines[index:]:
                    if '</' + GRP['name'] + '>' in after:
                        num_found += 1
                    else:
                        grp_match = _is_group_directive(after)
                        if grp_match:
                            if grp_match['name'] == GRP['name']:
                                num_required += 1
                logging.debug('Found ' + str(num_found) + ' closing statements for ' + str(num_required) + ' required similar directives.')
                if num_found < num_required:
                    validation_issue('Group directive specification "' + l.strip() + '" does not have a matching closing statement.', line_number=(index + 1), critical=True)
                    send_email(
                        'Invalid group directive found',
                        INVALID_GROUP_DIRECTIVE,
                        'error'
                    )
                    exit(6)
            # ----- DocumentRoot -----
            DR = _directive_match(l, 'DocumentRoot')
            if DR:
                logging.debug('Validating DocumentRoot directive...')
                if DR.startswith('/'):
                    logging.debug('ABSOLUTE DOCUMENT ROOT: ' + DR)
                    if not os.path.isdir(DR):
                        validation_issue(rel_path, 'DocumentRoot directive specifies potentially non-existent directory "' + DR + '".', line_number=(index + 1))
                else:
                    logging.debug('RELATIVE DOCUMENT ROOT: ' + DR)
                    validation_issue(rel_path, 'Found relative-path DocumentRoot directive. Relative-path DocumentRoot directives will not be validated by mkconf.', line_number=(index + 1))
            # ----- ErrorLog -----
            ERRL = _directive_match(l, 'ErrorLog')
            if ERRL:
                logging.debug('Validating ErrorLog directive...')
                if ERRL.startswith('/'):
                    logging.debug('ABSOLUTE ERROR LOG: ' + ERRL)
                    ERRDIR = os.path.dirname(ERRL)
                    if not os.path.isdir(ERRDIR):
                        validation_issue(rel_path, 'ErrorLog directive specifies potentially non-existent parent directory "' + ERRDIR + '".', line_number=(index + 1))
                else:
                    logging.debug('RELATIVE ERROR LOG: ' + ERRL)
                    validation_issue(rel_path, 'Found relative-path ErrorLog directive. Relative-path ErrorLog directives will not be validated by mkconf.', line_number=(index + 1))
            # ----- Include -----
            IP = _directive_match(l, 'Include')
            if IP:
                logging.debug('Validating Include directive...')
                if not '*' in IP:
                    if IP.startswith('/'):
                        logging.debug('ABSOLUTE INCLUDE: ' + IP)
                        # If the full path happens to to be relative to the output
                        # directory, then we can search for the file relative to the
                        # working directory.
                        if not os.path.isfile(os.path.join(args.working_directory, os.path.relpath(IP, args.output))) and not os.path.isfile(IP):
                            validation_issue(rel_path, 'Include directive specifies potentially non-existent file "' + IP + '".', line_number=(index + 1))
                    else:
                        logging.debug('RELATIVE INCLUDE: ' + IP)
                        if not os.path.isfile(os.path.join(args.working_directory, IP)):
                            validation_issue(rel_path, 'Include directive specifies potentially non-existent file "' + IP + '".', line_number=(index + 1))
                else:
                    logging.debug('WILDCARD INCLUDE: ' + IP)
                    validation_issue(rel_path, 'Found wildcard include directive. Wildcard includes will not be validated by mkconf.', line_number=(index + 1))
            # ----- PidFile -----
            PID = _directive_match(l, 'PidFile')
            if PID:
                logging.debug('Validating PidFile directive...')
                if PID.startswith('/'):
                    logging.debug('ABSOLUTE PID FILE: ' + PID)
                    PIDDIR = os.path.dirname(PID)
                    if not os.path.isdir(PIDDIR):
                        validation_issue(rel_path, 'PidFile directive specifies potentially non-existent parent directory "' + PIDDIR + '".', line_number=(index + 1))
                else:
                    logging.debug('RELATIVE PID FILE: ' + PID)
                    validation_issue(rel_path, 'Found relative-path PidFile directive. Relative-path PidFile directives will not be validated by mkconf.', line_number=(index + 1))
            # ----- ServerAlias -----
            SA = _directive_match(l, 'ServerAlias')
            if SA:
                logging.debug('Validating ServerAlias directive...')
                logging.debug('SERVER ALIAS: ' + SA)
                if not valid_fqdn_regex.match(SA):
                    validation_issue(rel_path, 'Found ServerAlias directive with invalid host string "' + SA + '".', line_number=(index + 1), critical=True)
                    send_email(
                        'Invalid ServerAlias directive found',
                        INVALID_SERVER_NAME,
                        'error'
                    )
                    exit(6)
                SA_IP = ''
                try:
                    SA_IP = socket.gethostbyname(SA)
                except Exception as e:
                    validation_issue(rel_path, 'ServerAlias directive specification "' + SA + '" does not resolve in DNS.', line_number=(index + 1))
                    logging.warning('Relevant ServerAlias resolution exception: ' + str(e))
                if SA_IP:
                    logging.debug('SERVER ALIAS RESOLVED IP: ' + SA_IP)
            # ----- ServerName -----
            SN = _directive_match(l, 'ServerName')
            if SN:
                logging.debug('Validating ServerName directive...')
                logging.debug('SERVER NAME: ' + SN)
                if not valid_fqdn_regex.match(SN):
                    validation_issue(rel_path, 'Found ServerName directive with invalid host string "' + SN + '".', line_number=(index + 1), crtitical=True)
                    send_email(
                        'Invalid ServerName directive found',
                        INVALID_SERVER_NAME,
                        'error'
                    )
                    exit(6)
                SN_IP = ''
                try:
                    SN_IP = socket.gethostbyname(SN)
                except Exception as e:
                    validation_issue(rel_path, 'ServerName directive specification "' + SN + '" does not resolve in DNS.', line_number=(index + 1))
                    logging.warning('Relevant ServerName resolution exception: ' + str(e))
                if SN_IP:
                    logging.debug('SERVER NAME RESOLVED IP: ' + SN_IP)
            # ----- ServerRoot -----
            SR = _directive_match(l, 'ServerRoot')
            if SR:
                logging.debug('Validating ServerRoot directive...')
                if SR.startswith('/'):
                    logging.debug('ABSOLUTE SERVER ROOT: ' + SR)
                    if not os.path.isdir(SR):
                        validation_issue(rel_path, 'ServerRoot directive specifies potentially non-existent directory "' + SR + '".', line_number=(index + 1))
                else:
                    logging.debug('RELATIVE SERVER ROOT: ' + SR)
                    validation_issue(rel_path, 'Found relative-path ServerRoot directive. Relative-path ServerRoot directives are not allowed.', line_number=(index + 1), critical=True)
                    send_email(
                        'Relative-path ServerRoot directive found',
                        REL_SERVER_ROOT,
                        'error'
                    )
                    exit(6)
            # ----- SSLCACertificateFile -----
            CA = _directive_match(l, 'SSLCACertificateFile')
            if CA:
                logging.debug('Validating SSLCACertificateFile directive...')
                if CA.startswith('/'):
                    logging.debug('ABSOLUTE SSL CA CERT: ' + CA)
                    if not os.path.isfile(CA):
                        validation_issue(rel_path, 'SSLCACertificateFile directive specifies potentially non-existent file "' + CA + '".', line_number=(index + 1))
                else:
                    logging.debug('RELATIVE SSL CA CERT: ' + CA)
                    validation_issue(rel_path, 'Found relative-path SSLCACertificateFile directive. Relative-path SSLCACertificateFile directives will not be validated by mkconf.', line_number=(index + 1))
            # ----- SSLCertificateFile -----
            CRT = _directive_match(l, 'SSLCertificateFile')
            if CRT:
                logging.debug('Validating SSLCertificateFile directive...')
                if CRT.startswith('/'):
                    logging.debug('ABSOLUTE SSL CERT: ' + CRT)
                    if not os.path.isfile(CRT):
                        validation_issue(rel_path, 'SSLCertificateFile directive specifies potentially non-existent file "' + CRT + '".', line_number=(index + 1))
                else:
                    logging.debug('RELATIVE SSL CERT: ' + CRT)
                    validation_issue(rel_path, 'Found relative-path SSLCertificateFile directive. Relative-path SSLCertificateFile directives will not be validated by mkconf.', line_number=(index + 1))
            # ----- SSLCertificateKeyFile -----
            KEY = _directive_match(l, 'SSLCertificateKeyFile')
            if KEY:
                logging.debug('Validating SSLCertificateKeyFile directive...')
                if KEY.startswith('/'):
                    logging.debug('ABSOLUTE SSL KEY: ' + KEY)
                    if not os.path.isfile(KEY):
                        validation_issue(rel_path, 'SSLCertificateKeyFile directive specifies potentially non-existent file "' + KEY + '".', line_number=(index + 1))
                else:
                    logging.debug('RELATIVE SSL KEY: ' + KEY)
                    validation_issue(rel_path, 'Found relative-path SSLCertificateKeyFile directive. Relative-path SSLCertificateKeyFile directives will not be validated by mkconf.', line_number=(index + 1))
            # ----- TransferLog -----
            TL = _directive_match(l, 'TransferLog')
            if TL:
                logging.debug('Validating TransferLog directive...')
                if TL.startswith('/'):
                    logging.debug('ABSOLUTE TRANSFER LOG: ' + TL)
                    TLDIR = os.path.dirname(TL)
                    if not os.path.isdir(TLDIR):
                        validation_issue(rel_path, 'TransferLog directive specifies potentially non-existent parent directory "' + TLDIR + '".', line_number=(index + 1))
                else:
                    logging.debug('RELATIVE TRANSFER LOG: ' + TL)
                    validation_issue(rel_path, 'Found relative-path TransferLog directive. Relative-path TransferLog directives will not be validated by mkconf.', line_number=(index + 1))
    # Send an email with all of the warnings, if there are any.
    if email_warnings:
        send_email(
            'Unable to validate environment',
            VALIDATION_WARNINGS + email_warnings,
            'warning'
        )        


def validate_environment():
    '''
    Validates that the executing environment is sufficient to proceed.
    '''
    print(_step('Validating working environment...'))
    logging.info('Validating working environment...')
    print(_substep('Validating rsync executable path...'))
    logging.debug('Validating rsync executable path...')
    if not os.path.isfile(args.rsync_executable):
        printe(_subsubstep('Specified rsync executable path does not exist.', C_RED))
        logging.critical('Specified rsync executable path does not exist.')
        send_email(
            'Unable to validate environment',
            RSYNC_DOESNT_EXIST,
            'error'
        )
        exit(2)
    print(_substep('Validating template source directories...'))
    logging.debug('Validating template source directories...')
    if not os.path.isdir(args.template_source):
        printe(_subsubstep('Specified template source directory does not exist.', C_RED))
        logging.critical('Specified template source directory does not exist.')
        send_email(
            'Unable to validate environment',
            TEMPLATE_SOURCE_DIR_DOESNT_EXIST,
            'error'
        )
        exit(2)
    if not os.path.isdir(os.path.join(args.template_source, 'conf')):
        printe(_subsubstep('The "conf" subdirectory within specified template source directory does not exist.', C_RED))
        logging.critical('The "conf" subdirectory within specified template source directory does not exist.')
        send_email(
            'Unable to validate environment',
            TEMPLATE_CONF_DIR_DOESNT_EXIST,
            'error'
        )
        exit(2)
    if not os.path.isdir(os.path.join(args.template_source, 'vhosts.d')):
        printe(_subsubstep('The "vhosts.d" subdirectory within specified template source directory does not exist.', C_RED))
        logging.critical('The "vhosts.d" subdirectory within specified template source directory does not exist.')
        send_email(
            'Unable to validate environment',
            TEMPLATE_VHOST_DIR_DOESNT_EXIST,
            'error'
        )
        exit(2)
    print(_substep('Validating template source files...'))
    logging.debug('Validating template source files...')
    if not os.path.isfile(os.path.join(args.template_source, 'conf/httpd.conf')):
        printe(_subsubstep('The "httpd.conf" template within the "conf" subdirectory of the specified template source directory does not exist.', C_RED))
        logging.critical('The "httpd.conf" template within the "conf" subdirectory of the specified template source directory does not exist.')
        send_email(
            'Unable to validate environment',
            TEMPLATE_HTTPD_CONF_DOESNT_EXIST,
            'error'
        )
        exit(2)
    print(_substep('Validating template configuration file...'))
    logging.debug('Validating template configuration file...')
    if not os.path.isfile(args.template_conf):
        if not os.path.isdir(args.template_conf):
            printe(_subsubstep('Specified template configuration file does not exist.', C_RED))
            logging.critical('Specified template configuration file does not exist.')
            send_email(
                'Unable to validate environment',
                TEMPLATE_CONF_DOESNT_EXIST,
                'error'
            )
            exit(2)
        else:
            logging.debug('Selecting suitable template configuration file within specified directory...')
            files = [x for x in os.listdir(args.template_conf) if os.path.isfile(os.path.join(args.template_conf, x))]
            if not files:
                printe(_subsubstep('Specified template configuration file directory does not contain any template configuration files.', C_RED))
                logging.critical('Specified template configuration file directory does not contain any template configuration files.')
                send_email(
                    'Unable to validate environment',
                    TEMPLATE_CONF_DOESNT_EXIST,
                    'error'
                )
                exit(2)
            elif 'mkconf.yaml' in files:
                args.template_conf = os.path.join(args.template_conf, 'mkconf.yaml')
            elif hostname + '.yaml' in files:
                args.template_conf = os.path.join(args.template_conf, hostname + '.yaml')
            else:
                found_match = False
                for f in files:
                    if f.rsplit('.', 1)[0] in hostname:
                        args.template_conf = os.path.join(args.template_conf, f)
                        found_match = True
                        break
                if not found_match:
                    printe(_subsubstep('Specified template configuration file directory does not contain any selectable template configuration files.', C_RED))
                    logging.critical('Specified template configuration file directory does not contain any selectable template configuration files.')
                    send_email(
                        'Unable to validate environment',
                        TEMPLATE_CONF_DOESNT_EXIST,
                        'error'
                    )
                    exit(2)
            printe(_subsubstep('Automatically selected template configuration file "' + args.template_conf + '".', C_BLUE))
            logging.info('Automatically selected template configuration file "' + args.template_conf + '".')
    print(_substep('Validating working directory...'))
    logging.debug('Validating working directory...')
    if os.path.isfile(args.working_directory):
        printe(_subsubstep('Specified working directory is an existing file.', C_RED))
        logging.critical('Specified working directory is an existing file.')
        send_email(
            'Unable to validate environment',
            WORKING_DIR_IS_FILE,
            'error'
        )
        exit(2)
    if os.path.isdir(args.working_directory):
        logging.debug('Working directory already exists. Deleting previous working directory...')
        try:
            shutil.rmtree(args.working_directory)
        except Exception as e:
            printe(_subsubstep('Unable to delete previous working directory - ' + str(e) + '.', C_RED))
            logging.critical('Unable to delete previous working directory - ' + str(e) + '.')
            send_email(
                'Unable to validate environment',
                CANT_DELETE_WORKING_DIR,
                'error'
            )
            exit(2)
    logging.debug('Creating working directory...')
    try:
        os.makedirs(args.working_directory)
    except Exception as e:
        printe(_subsubstep('Unable to create working directory - ' + str(e) + '.', C_RED))
        logging.critical('Unable to create working directory - ' + str(e) + '.')
        send_email(
            'Unable to validate environment',
            CANT_CREATE_WORKING_DIR,
            'error'
        )
        exit(2)


def write_output():
    '''
    Transfers the newly generated configuration files from the working directory
    to the specified output directory. Also reloads or restarts the Apache Web Server
    service if specified.
    '''
    if args.dry_run:
        print(_step('Finalizing configuration process (DRY RUN)...'))
        logging.info('Finalizing configuration process (DRY RUN)...')
    else:
        print(_step('Finalizing configuration process...'))
        logging.info('Finalizing configuration process...')
    logging.debug('Looking for existing output directory...')
    if os.path.isdir(args.output):
        if args.do_backup:
            logging.debug('Output directory already exists. Checking for previous backup directories...')
            if not os.path.isdir(args.output.rstrip('/') + '.backup'):
                logging.debug('Creating backup directory...')
                try:
                    os.makedirs(args.output.rstrip('/') + '.backup')
                except Exception as e:
                    printe(_subsubstep('Unable to create backup directory - ' + str(e) + '.', C_RED))
                    logging.critical('Unable to create backup directory - ' + str(e) + '.')
                    send_email(
                        'Unable to create backup directory',
                        CANT_CREATE_BACKUP_DIR,
                        'error'
                    )
                    exit(7)
            print(_substep('Creating backup of existing configuration...'))
            logging.info('Creating backup of existing configuration...')
            try:
                (b_o, b_ec) = _rsync(
                    args.output.rstrip('/') + '/',
                    args.output.rstrip('/') + '.backup/',
                    '-a -h --delete --progress'
                )
            except Exception as e:
                printe(_subsubstep('Unable to create backup - ' + str(e) + '.', C_RED))
                logging.critical('Unable to create backup - ' + str(e) + '.')
                send_email(
                    'Unable to create backup',
                    CANT_CREATE_BACKUP,
                    'error'
                )
                exit(7)
            logging.debug('BACKUP RSYNC EXIT CODE: ' + str(b_ec))
            if b_ec != 0:
                if b_o:
                    for l in b_o:
                        logging.critical('BACKUP RSYNC OUTPUT: ' + l)
                printe(_subsubstep('Unable to create backup - subprocess returned non-zero exit code.', C_RED))
                logging.critical('Unable to create backup - subprocess returned non-zero exit code.')
                send_email(
                    'Unable to create backup',
                    CANT_CREATE_BACKUP,
                    'error'
                )
                exit(7)
            else:
                if b_o:
                    for l in b_o:
                        logging.debug('BACKUP RSYNC OUTPUT: ' + l)
        else:
            logging.debug('Output directory exists but backups are disabled.')
    else:
        logging.debug('Output directory doesn\'t exist. Creating output directory...')
        try:
            os.makedirs(args.output)
        except Exception as e:
            printe(_subsubstep('Unable to create output directory - ' + str(e) + '.', C_RED))
            logging.critical('Unable to create output directory - ' + str(e) + '.')
            send_email(
                'Unable to create output directory',
                CANT_CREATE_OUTPUT_DIR,
                'error'
            )
            exit(7)
    print(_substep('Writing configuration files to output directory...'))
    logging.info('Writing configuration files to output directory...')
    rsync_args = '-a -h --progress'
    if args.delete: rsync_args += ' --delete'
    rsync_args += ' --exclude logs --exclude modules --exclude run'
    if args.exclude and args.exclude[0]:
        for x in args.exclude:
            rsync_args += ' --exclude ' + x
    logging.debug('OUTPUT RSYNC ARGS: ' + rsync_args)
    try:
        (w_o, w_ec) = _rsync(
            args.working_directory.rstrip('/') + '/',
            args.output.rstrip('/') + '/',
            rsync_args
        )
    except Exception as e:
        printe(_subsubstep('Unable to write files to output directory - ' + str(e) + '.', C_RED))
        logging.critical('Unable to write files to output directory - ' + str(e) + '.')
        send_email(
            'Unable to write files to output directory',
            CANT_WRITE_OUTPUT,
            'error'
        )
        exit(7)
    logging.debug('OUTPUT RSYNC EXIT CODE: ' + str(w_ec))
    if w_ec != 0:
        if w_o:
            for l in w_o:
                logging.critical('OUTPUT RSYNC OUTPUT: ' + l)
        printe(_subsubstep('Unable to write files to output directory - subprocess returned non-zero exit code.', C_RED))
        logging.critical('Unable to write files to output directory - subprocess returned non-zero exit code.')
        send_email(
            'Unable to write files to output directory',
            CANT_WRITE_OUTPUT,
            'error'
        )
        exit(7)
    else:
        if w_o:
            for l in w_o:
                logging.debug('OUTPUT RSYNC OUTPUT: ' + l)     
     

# --------------------------------------



# ---------- Boilerplate Magic ---------

if __name__ == '__main__':
    try:
        main()
    except (KeyboardInterrupt, EOFError) as ki:
        sys.stderr.write('Recieved keyboard interrupt!\n')
        exit(100)

# --------------------------------------
